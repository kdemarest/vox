<!DOCTYPE HTML>
<html>
<head>
<title>Vox - a test bed</title>

<!-- Character encoding -->
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<!-- Stylesheet -->
<link href="style/main.css" rel="stylesheet" type="text/css">

<!-- Modules -->
<script src="js/jquery.3.3.1.js" charset="utf-8"></script>
<script src="js/glMatrix-1.2.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jimp/0.14.0/jimp.js" charset="utf-8"></script>

<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
<script src="js/utilModule.js" type="text/javascript"></script>
<script src="js/utilPlugin.js" type="text/javascript"></script>
<script src="js/utilities.js" type="text/javascript"></script>
<script src="js/utilPick.js" type="text/javascript"></script>
<script src="js/utilChance.js" type="text/javascript"></script>
<script src="js/utilTextMapParser.js" charset="utf-8"></script>
<script src="js/utilRoller.js" charset="utf-8"></script>
<script src="js/types.js" type="text/javascript"></script>
<script src="js/data.js" type="text/javascript"></script>
<script src="js/dataStickers.js" type="text/javascript"></script>
<script src="js/rules.js" charset="utf-8"></script>
<script src="js/dataPicker.js" charset="utf-8"></script>
<script src="js/dataTiles.js" charset="utf-8"></script>
<script src="js/dataEffects.js" charset="utf-8"></script>
<script src="js/dataItems.js" charset="utf-8"></script>
<script src="js/dataMonsters.js" charset="utf-8"></script>
<script src="js/dataThemes.js" charset="utf-8"></script>
<script src="js/dataPlaces.js" charset="utf-8"></script>
<script src="js/dataChecker.js" charset="utf-8"></script>
<script src="js/dataPicker.js" charset="utf-8"></script>
<script src="js/dataMason.js" charset="utf-8"></script>
<script src="js/dataSeedTile.js" charset="utf-8"></script>
<script src="js/dataSeedBlock.js" charset="utf-8"></script>
<script src="js/dataSeed.js" charset="utf-8"></script>
<script src="js/map2d.js" charset="utf-8"></script>
<script src="js/map3d.js" charset="utf-8"></script>
<script src="js/seed.js" charset="utf-8"></script>
<script src="js/dataWright.js" charset="utf-8"></script>
<script src="js/path.js" charset="utf-8"></script>
<script src="js/place.js" charset="utf-8"></script>

<script src="js/map.js" type="text/javascript"></script>
<script src="js/mapMaker.js" type="text/javascript"></script>


<script src="js/textureWriter.js" type="text/javascript"></script>
<script src="js/textureRepo.js" type="text/javascript"></script>
<script src="js/config.js" type="text/javascript"></script>
<script src="js/light.js" type="text/javascript"></script>
<script src="js/world.js" type="text/javascript"></script>
<script src="js/blocks.js" type="text/javascript"></script>
<script src="js/helpers.js" type="text/javascript"></script>
<script src="js/pickBlock.js" type="text/javascript"></script>
<script src="js/render.js" type="text/javascript"></script>
<script src="js/controls.js" type="text/javascript"></script>
<script src="js/body.js" type="text/javascript"></script>
<script src="js/viewMaterial.js" type="text/javascript"></script>
<script src="js/entity.js" type="text/javascript"></script>
<script src="js/player.js" type="text/javascript"></script>
<script src="js/game.js" type="text/javascript"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jimp/0.14.0/jimp.js" charset="utf-8"></script>

</head>

<body oncontextmenu="return false">
<!-- Render surface -->
<canvas id="renderSurface"></canvas>

<!-- Material selection -->
<table id="materialSelector">
	<tr></tr>
</table>

<!-- Initialisation code -->
<script type="text/javascript">

Module.add( 'playerControls', ()=> {

	class PlayerControls extends Controls {
		constructor(canvas,player) {
			super(canvas,player);

			this.addListener();
			this.pointerLock();
			this.keyDef['Tab'] = (target,value) => {
				if( !value ) return;
				if( this.isPointerLocked ) {
					this.pointerUnlock();
				}
				else {
					this.pointerLock();
				}
			}
			this.keyDef['g'] = this.keyDef['G'] =	(target,value) => { if( value ) target.collide = !target.collide; }
			this.keyDef['r'] = this.keyDef['R'] =	(target,value) => { target.up = value; }
			this.keyDef['f'] = this.keyDef['F'] =	(target,value) => { target.up = -value; }

			this.keyDef['w'] = this.keyDef['W'] =	(target,value) => { target.forward = value; }
			this.keyDef['s'] = this.keyDef['S'] =	(target,value) => { target.forward = -value; }
			this.keyDef['a'] = this.keyDef['A'] =	(target,value) => { target.sideways = value; }
			this.keyDef['d'] = this.keyDef['D'] =	(target,value) => { target.sideways = -value; }
			this.keyDef['c'] = this.keyDef['C'] =	(target,value) => {
				if( value ) {
					if( target.crawl && !target.mayExitCrawl() ) {
						return;
					}

					if( target.crouch ) { target.crawl = true; target.crouch = false; }
					else { target.crawl = false; target.crouch = true; }
				}
			}
			this.keyDef[' '] = (target,value) => {
				console.log('space pressed='+value);
				if( value ) {
					if( target.crawl && !target.mayExitCrawl() ) {
						return;
					}

					target.crouch = false;
					target.crawl = false;
					target.jump = true;
				}
			}
			this.keyDef['Shift'] = (target,value) => {
				if( !target.sprint && target.crouch ) {
					target.crouch = false;
				}
				if( !target.sprint && target.crawl ) {
					if( !target.mayExitCrawl() ) {
						return;
					}
					target.crawl = false;
				}
				target.sprint = target.crouch || target.crawl ? false : !!value;
			}
			this.mouseDef.move = (target,dx,dy) => {
				target.addYaw(dx);
				target.addPitch(-dy);
			}
			this.mouseDef.click = (target,rmb) => {
				target.doBlockAction(
					canvas.width/2,
					canvas.height/2,
					!rmb,
					(...args) => {
						let r = canvas.renderer;
						r.pickBlock.setup( r.viewMatrix, r.projMatrix, r.modelMatrix );
						return r.pickBlock.pickAt(r.world, ...args);
					}
				);
			}
		}
	}

	return {
		PlayerControls: PlayerControls
	}

});

let consoleLog = console.log;
let consoleCount = 10000;
console.log = (...args) => {
	consoleCount++;
	consoleLog(consoleCount,...args);
}

function mapGenerate() {

	let palette = {
		bridge:			"bridge",
		door:			"door",
		fillFloor:		"floorDirt",
		fillWall:		"wallCave",
		floor:			"floorDirt",
		outlineWall:	"wallCave",
		passageFloor:	"floorStone",
		wall:			"wallCave"
	};

	let sideDimension = 150; //Random.intRange(40,150);

	// Floor Density
	// 0.10 - 0.30 - spindly maps. Below 0.10 it is all just passage.
	// 0.40 - 0.50 - lanky, with generally thick passages
	// 0.60 - 0.70 - Pretty chunky rooms
	// 0.80 - 0.90 - Vast open spaces with stone columns intruding
	// Seed Percent
	// Lower number (0.05) means each room is more consolidated
	// Higher number (0.50) means lots of little rooms that connect.
	// floor=0.50, seed 0.02, passageWander false, makes nice connected rooms

	let level = 1;
	let theme = ThemeList.coreBridges; //caveRoomsNarrowlyConnected; //coreBridges; //dwarfVillage; //coreCavernRooms;
	theme = Object.assign( {}, theme, ScapeList[theme.scapeId]() );
	theme.dim = sideDimension;
	theme.depth = level;
	//debugger;
	//theme.palette = palette;
	// NOTICE that I am NOT passing the theme's scape, but instead overriding it
	// so that you can tweak it.


	console.log(theme);

	let injectList = [];
	let tileQuota  = [];
	let siteList   = [];

	let masonMap = (new Mason).construct(
		theme,
		tileQuota,
		injectList,
		siteList
	);
	
	return masonMap.renderToString();
}

let wrightToWorld = (map,world) => {
	world.bulkChangeBegin();
	let count = 0;
	map.traverse( (x,y,z) => {
		let b = BLOCK[map.getBlock(x,y,z).toBLOCK];
		console.assert(b);
		let zoneId = map.getZoneId(x,y,z);
		if( b==BLOCK.DIRT && (zoneId%2)==1 ) { // !== -1 && wright.driver.getZone(zoneId).wallToggle ) {
			b = BLOCK.BRICK;
		}
		if( world.contains(x,y,z) ) {
			world.setBlock(x,y,z,b);
			count += 1;
		}
	});
	world.bulkChangeEnd();
}


async function main(){

	function onImageComplete( status, imgStem, resource ) {
		render.onImageComplete( status, imgStem, resource );
	}

	window.IMG_BASE = "media/";
	let pseudoRandomSeed = 2622;
	let flogueConfigEnvVariableId = 'flogueConfigId';

	window.openGl = new OpenGl( "renderSurface" );

	let game = new Game( pseudoRandomSeed, flogueConfigEnvVariableId );

	let nullChecker = {
		checkSupply: ()=>{},
		checkLoot: ()=>{},
		checkResistance: ()=>{}
	};

	window.PLUGIN_BASE = "js/";

	await game.initPlugins( [ 'pkgPlantsBasic' ] );
	await game.initTypes( ()=>nullChecker );
	await game.initImages( onImageComplete, 250 );


	let world = new World();

//	let mapString = mapGenerate();
//	let mapMaker = new MapMaker(mapString);
//	world.init(mapMaker.map.xLen,mapMaker.map.yLen,16);
//	world.createFlatWorld( 16 );
//	mapMaker.makeIntoWorld(world);

	let pathControls = {
		rgDist: new Roller.Range(12,30,'intRange'),
		ctRise: new Roller.ChanceTo(10),
		ctFall: new Roller.ChanceTo(10),
		rgWidth: new Roller.Range(0,1,'intRange',3,2),
		lightSpacing: 16,
	}
	let wright = new Wright().init( 16*8, 16*8, 16*8, pathLength=30*8, pathControls );

	world.init(wright.map3d.xLen,wright.map3d.yLen,wright.map3d.zLen);
	world.createFlatWorld( 30 );	// dirt below, air above.
	brainlessLight(world);
	let head = wright.driver.head;
	world.spawnPoint = new Vector(head.x, head.y, head.z+1);
	
	// Set up renderer
	var render = new Renderer( window.openGl );
	render.setWorld( world, 8 );
	render.setPerspective( 60, 0.01, 200 );
	
	// Create new local player
	let player = new Player();
	player.body.setWorld( world );
	player.viewMaterial.setMaterialSelector( "materialSelector" );
	//player.body.collide = false;

	let canvas = document.getElementById('renderSurface');
	let controls = new PlayerControls(canvas,player.body);

	wright._renderFn = (map) => wrightToWorld(map,world);

	window.tickCall = function() {
		var time = new Date().getTime() / 1000.0;
		
		// Update local player
		player.body.update();
		
		// Build a chunk
		render.buildChunks( 1 );
		//render.buildWorld();
		
		// Draw world
		render.setCamera( player.body.getEyePos().toArray(), player.body.angles );
		render.draw();

		wright.tick();
	}

	window.tick = function() {
		window.tickCall();
		window.requestAnimationFrame(window.tick)
	}

	window.requestAnimationFrame(window.tick);
}

Module.entryPoint( () => {
	Profile.end('scripts').tell();
	main();
});

</script>

</body>
</html>